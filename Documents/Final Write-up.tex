\documentclass[11pt]{article}
% used by \maketitle :
\title{Additive Synthesis and Genetic Algorithms} 
\author{Nathan  Griffith}
\date{February 4, 2010}
% used by \begin{code}:
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}

\begin{document}
\maketitle % automatic title!

\section{Abstract}
The purpose of this project is to explore and manipulate sound in the frequency domain. To do so, a genetic algorithm is used as a gateway to a \emph{path} or \emph{space} between two sounds. 

The goal is not to simply devise method of rendering the target sound, as this can be done without a genetic algorithm. Instead, the goal is to allow for the exploration the \emph{path} that is generated by the algorithm. In other words, a wide range of unexplored sounds can be found on a path that is driven by random mutations and alterations. 

\section{Introduction}

The idea is based on a technique presented through Michael Chinen and Naotoshi Osaka's \emph{Genesynth}\cite{genesynth}.

\section{The Genetic Algorithm}
The Genetic Algorithm used in this project follows a fairly standard format. Given a \bf{starting sound} and a \bf{target sound}, incremental, random changes are applied to the starting sound. With each generation, a population of the ``most fit'' sounds are carried onto the next iteration of the algorithm. This ``fitness'' determination can be any form of comparison to the \bf{target sound}. Once the algorithm stops, each generation is stored in a history list, which can then be ``explored'' through a number of means. The algorithm will stop running after a specified number of generations, or after the sound has completely converged to match the target sound. 

\section{The Basics}
To get started, one must simply point ghci to the file "SoundDataLibrary.lhs," which has a number of default functions and instruments.
Next, one must choose a starting sound, a target sound, the maximum number of iterations the algorithm should run before stopping, and the name of the output (i.e. "out.wav"). Here is an example of this function call:
\begin{code}
> simpleBasic hornBasic guitarBasic 1000 "horn_to_guitar_basic.wav"
> simpleNormal hornNormal guitarNormal 1000 30.0 "horn_to_guitar.wav"
\end{code}
Note that \emph{simpleNormal} also takes a duration value (in this case, 30.0 seconds), which tells it the maximum length of audio to render.
Notice that "hornBasic" and "guitarBasic" are already defined. A number of other example instrument sounds have been included in this file. Custom instruments can also be defined and used. (How this is done will be discussed in a later section).


\section{Further Customizing the Algorithm}
\textbf{TODO} In addition: I split the GA into a few files -- one to handle mutations, one to handle mating/crossover, one to handle comparison and determining favorability of individuals in a generation, one to handle the higher level GA iterations, and a couple to handle things like sorting sound representations and generating random numbers. It's all quite modular. (For instance, at the upper-most level of the GA, different mutation functions can be specified, allowing users of the algorithm to more freely manipulate the way in which the algorithm ends up converging)

\subsection{Mutations}
The \emph{processPopulation} function takes a a list of mutation functions as the \emph{mutOptions} argument. One such list, with mutation functions for manipulating both the frequency and amplitude of a \emph{SoundPartial}, might look as follows:
\begin{code}
> mutOptionsB :: (RandomGen g) => g -> [SoundRoot -> (SoundRoot,g)]
> mutOptionsB gen = [mutateFreqB gen,mutateAmplB gen]
\end{code}
This allows for the specification and customization of any number of mutation functions. If, for instance, one were not satisfied with the number of generations required for partials to change frequency, a completely new mutation function could be specified which would allow individual partials to leap long distances (up to 500Hz in this case) with each generation\footnote{While this approach would cause \emph{SoundData} types with large differences in frequency to converge more rapidly early on, this function would only become a nuisance when the algorithm attempts to fine-tune the frequency of each partial. A better approach would be to strike a balance between the initial speed of convergence and the ability for mutations to make very small adjustments during later iterations.}:
\begin{code}
> -- mutate the frequency of a SoundRoot (very large leaps)
> mutateFreqB_BIG :: (RandomGen g) => g -> SoundRoot -> (SoundRoot,g)
> mutateFreqB_BIG gen (Sine f a) = ((Sine new_f a),new_gen)
>   where out = (mutateDouble gen 500.0 f)
>         new_gen = snd out
>         new_f = fst out
\end{code}
Note that each mutation function, as well as the list of mutation functions, takes a random number generator as an argument. In addition, the mutation functions return both the modified partial and a new generator for later use. Because the generator is explicitly passed to the function, one can generate as many random numbers as needed, including none at all. In other words, the exact purpose of the \emph{randomness} can be hand-tailored for each function.
\subsection{Mating and Crossover}

\subsection{The Fitness Function}

\section{Reading from a file}

\section{Rendering}
The \emph{SoundData} would not be very useful without a way to render audio. For this, an additive synthesis approach is taken, using Euterpea's \emph{csound} implementation. (Brief explanation of CSound and Euterpea's arrow notation). Each partial is synthesised using a single \emph{oscil} sine oscillator, and envelopes are generated using the \emph{linseg} function.
5. I wrote a function that inputs two "basic" sound representations into the GA ,and which then outputs a single sound sample. This sample plays, over time, the convergence from one representation into the other. (This, incidentally, uses the "complex" representation level, as both the frequency and the amplitude of each partial can change over time, so you could see it as taking the "basic" representation and adding a time dimension). I've included a link to an example of this particular function at work, as I feel this approach best represents my GA as a whole. (A word of warning, the "starting" tone is not the prettiest sound, so make sure your volume is not too high).

\section{Possible Applications}

\section{Conclusion}


\begin{thebibliography}{2}

	\bibitem{genesynth}
	  Michael Chinen and Naotoshi Osaka,
	  \emph{Noise Band-based Genetic Algorithm Analysis/Synthesis Framework}.
	  Tokyo Denki University,
	  2007.
	\bibitem{synthbot}
	  Matthew Yee-King, Martin Roth,
	  \emph{Synthbot: An Unsupervised Software Synthesizer Programmer}.
	  International Computer Music Conference,
	  2008.

\end{thebibliography}
\end{document}             % End of document.
